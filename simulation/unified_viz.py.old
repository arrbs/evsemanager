#!/usr/bin/env python3
"""
Unified visualization for EVSE simulation results.
Shows all key metrics in one comprehensive graph for easy analysis.
"""

import json
import sys
from pathlib import Path
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import numpy as np


def load_results(filepath: str) -> dict:
    """Load simulation results from JSON file."""
    with open(filepath) as f:
        return json.load(f)


def plot_unified(results: dict, output_file: str = None):
    """Create unified visualization with all key metrics."""
    history = results['history']
    summary = results['summary']
    
    # Extract time series data
    times_sec = [h['time'] for h in history]
    times_hours = [t/3600 for t in times_sec]
    
    pv_power = [h['pv_power'] for h in history]
    house_load = [h['house_load'] for h in history]
    battery_power = [h['battery_power'] for h in history]
    battery_soc = [h['battery_soc'] for h in history]
    grid_power = [h['grid_power'] for h in history]
    ev_load = [h.get('ev_load', 0) for h in history]
    ev_load_actual = [h.get('ev_load_actual', h.get('ev_load', 0)) for h in history]
    charger_current = [h.get('charger_current', 0) for h in history]
    charger_current_actual = [h.get('charger_current_actual', h.get('charger_current', 0)) for h in history]
    available_power = [h.get('available_power', 0) for h in history]
    load_spikes = [h.get('load_spikes', 0) for h in history]
    
    # Create figure with 4 subplots
    fig, axes = plt.subplots(4, 1, figsize=(16, 12), sharex=True)
    fig.suptitle(f"{summary['scenario']} - {summary['duration_hours']}h Simulation", 
                 fontsize=16, fontweight='bold')
    
    # Calculate total load (house + EV)
    total_load = [h + e for h, e in zip(house_load, ev_load)]
    
    # Subplot 1: Power Flow
    ax1 = axes[0]
    ax1.plot(times_hours, pv_power, 'gold', linewidth=2.5, label='Solar PV', zorder=5)
    ax1.plot(times_hours, total_load, 'red', linewidth=2, label='Total Load (House+EV)', 
             linestyle='-', alpha=0.8, zorder=4)
    ax1.plot(times_hours, house_load, 'gray', linewidth=1.5, label='House Load', 
             linestyle=':', alpha=0.6, zorder=3)
    ax1.plot(times_hours, [-p for p in battery_power], 'green', linewidth=1.5, 
             label='Battery Power', linestyle='--', alpha=0.7, zorder=2)
    ax1.fill_between(times_hours, 0, load_spikes, alpha=0.3, color='orange', label='Load Spikes', zorder=1)
    ax1.axhline(0, color='black', linewidth=0.5, alpha=0.3)
    ax1.set_ylabel('Power (W)', fontsize=11)
    ax1.set_title('Power Flow (PV should match Total Load when battery full)', fontsize=12, fontweight='bold')
    ax1.legend(loc='upper right', fontsize=9)
    ax1.grid(True, alpha=0.3)
    
    # Subplot 2: EV Charging (with sensor delay)
    ax2 = axes[1]
    ax2_twin = ax2.twinx()
    
    # Available power
    ax2.plot(times_hours, available_power, 'gold', linewidth=2, label='Available Power', alpha=0.8)
    
    # EV power (actual vs sensors)
    if any(a != s for a, s in zip(ev_load_actual, ev_load)):
        ax2.plot(times_hours, ev_load, 'blue', linewidth=1.5, linestyle='--', 
                label='EV Power (sensors)', alpha=0.7)
        ax2.plot(times_hours, ev_load_actual, 'red', linewidth=2, 
                label='EV Power (actual)', alpha=0.8)
    else:
        ax2.plot(times_hours, ev_load, 'blue', linewidth=2, label='EV Power')
    
    # Current on secondary axis
    if any(a != s for a, s in zip(charger_current_actual, charger_current)):
        ax2_twin.plot(times_hours, charger_current, 'cyan', linewidth=1, linestyle='--',
                     label='Current (sensors)', alpha=0.6)
        ax2_twin.plot(times_hours, charger_current_actual, 'purple', linewidth=1.5,
                     label='Current (actual)', alpha=0.7)
    else:
        ax2_twin.plot(times_hours, charger_current, 'purple', linewidth=1.5, 
                     label='Current', alpha=0.7)
    
    ax2.axhline(0, color='black', linewidth=0.5, alpha=0.3)
    ax2.set_ylabel('Power (W)', fontsize=11)
    ax2_twin.set_ylabel('Current (A)', fontsize=11, color='purple')
    ax2_twin.tick_params(axis='y', labelcolor='purple')
    ax2.set_title('EV Charging & Available Power', fontsize=12, fontweight='bold')
    
    # Combine legends
    lines1, labels1 = ax2.get_legend_handles_labels()
    lines2, labels2 = ax2_twin.get_legend_handles_labels()
    ax2.legend(lines1 + lines2, labels1 + labels2, loc='upper right', fontsize=9)
    ax2.grid(True, alpha=0.3)
    
    # Subplot 3: Battery State
    ax3 = axes[2]
    ax3_twin = ax3.twinx()
    
    ax3.plot(times_hours, battery_power, 'green', linewidth=2, label='Battery Power')
    ax3.axhline(0, color='black', linewidth=0.5, alpha=0.3)
    ax3_twin.plot(times_hours, battery_soc, 'blue', linewidth=2, label='Battery SOC')
    
    ax3.set_ylabel('Power (W)', fontsize=11, color='green')
    ax3.tick_params(axis='y', labelcolor='green')
    ax3_twin.set_ylabel('SOC (%)', fontsize=11, color='blue')
    ax3_twin.tick_params(axis='y', labelcolor='blue')
    ax3_twin.set_ylim([0, 100])
    ax3.set_title('Battery State', fontsize=12, fontweight='bold')
    
    lines1, labels1 = ax3.get_legend_handles_labels()
    lines2, labels2 = ax3_twin.get_legend_handles_labels()
    ax3.legend(lines1 + lines2, labels1 + labels2, loc='upper right', fontsize=9)
    ax3.grid(True, alpha=0.3)
    
    # Subplot 4: Grid Import/Export
    ax4 = axes[3]
    grid_import = [max(0, g) for g in grid_power]
    grid_export = [-min(0, g) for g in grid_power]
    
    ax4.fill_between(times_hours, 0, grid_import, alpha=0.5, color='red', label='Grid Import')
    ax4.fill_between(times_hours, 0, [-g for g in grid_export], alpha=0.5, color='green', 
                     label='Grid Export')
    ax4.axhline(0, color='black', linewidth=0.5)
    ax4.set_ylabel('Power (W)', fontsize=11)
    ax4.set_xlabel('Time (hours)', fontsize=11)
    ax4.set_title('Grid Flow', fontsize=12, fontweight='bold')
    ax4.legend(loc='upper right', fontsize=9)
    ax4.grid(True, alpha=0.3)
    
    # Add summary statistics as text box
    stats_text = (
        f"EV Energy: {summary['ev_energy_kwh']:.1f} kWh\n"
        f"Charging: {summary['charging_hours']:.1f}h ({summary['charging_hours']/summary['duration_hours']*100:.0f}%)\n"
        f"Solar: {summary['solar_percent']:.1f}%\n"
        f"SOC: {summary['car_soc_start']}% â†’ {summary['car_soc_end']}% (+{summary['soc_gain']:.1f}%)\n"
        f"Grid Import: {summary['grid_import_kwh']:.2f} kWh\n"
        f"Adjustments: {summary['adjustments']}"
    )
    
    fig.text(0.02, 0.02, stats_text, fontsize=10, family='monospace',
             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5),
             verticalalignment='bottom')
    
    plt.tight_layout(rect=[0, 0.05, 1, 0.98])
    
    if output_file:
        plt.savefig(output_file, dpi=150, bbox_inches='tight')
        print(f"Saved visualization to {output_file}")
    else:
        plt.show()
    
    plt.close()


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: python3 unified_viz.py <results.json> [output.png]")
        sys.exit(1)
    
    results_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    if not Path(results_file).exists():
        print(f"Error: File not found: {results_file}")
        sys.exit(1)
    
    results = load_results(results_file)
    plot_unified(results, output_file)
    
    print(f"\nScenario: {results['summary']['scenario']}")
    print(f"Duration: {results['summary']['duration_hours']}h")
    print(f"EV Energy: {results['summary']['ev_energy_kwh']:.1f} kWh")
    print(f"Solar %: {results['summary']['solar_percent']:.1f}%")
    print(f"SOC Gain: {results['summary']['soc_gain']:.1f}%")


if __name__ == '__main__':
    main()
